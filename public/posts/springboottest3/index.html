<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring Boot Software Testing 3 - White Box Testing and Coverage | Mr.W's Blog</title>
<meta name=keywords content="Spring Boot,Java,Actuator"><meta name=description content="White Box Testing and Coverage Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application&rsquo;s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software&rsquo;s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments."><meta name=author content="Mr.W"><link rel=canonical href=https://www.mrwblog.com/posts/springboottest3/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.01a996bd8bc49a236056f0facc1b09307c5c6829e3b89b8c08bf0ed176f60791.css integrity="sha256-AamWvYvEmiNgVvD6zBsJMHxcaCnjuJuMCL8O0Xb2B5E=" rel="preload stylesheet" as=style><link rel=icon href=https://www.mrwblog.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://www.mrwblog.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://www.mrwblog.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://www.mrwblog.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://www.mrwblog.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.mrwblog.com/posts/springboottest3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=disabled"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","disabled")}</script><meta property="og:title" content="Spring Boot Software Testing 3 - White Box Testing and Coverage"><meta property="og:description" content="White Box Testing and Coverage Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application&rsquo;s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software&rsquo;s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments."><meta property="og:type" content="article"><meta property="og:url" content="https://www.mrwblog.com/posts/springboottest3/"><meta property="og:image" content="https://www.mrwblog.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-01T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.mrwblog.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Spring Boot Software Testing 3 - White Box Testing and Coverage"><meta name=twitter:description content="White Box Testing and Coverage Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application&rsquo;s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software&rsquo;s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.mrwblog.com/posts/"},{"@type":"ListItem","position":2,"name":"Spring Boot Software Testing 3 - White Box Testing and Coverage","item":"https://www.mrwblog.com/posts/springboottest3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring Boot Software Testing 3 - White Box Testing and Coverage","name":"Spring Boot Software Testing 3 - White Box Testing and Coverage","description":"White Box Testing and Coverage Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application\u0026rsquo;s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software\u0026rsquo;s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments.","keywords":["Spring Boot","Java","Actuator"],"articleBody":"White Box Testing and Coverage Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application’s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software’s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments.\nThe Crucial Role of Structural Testing Enhanced Code Coverage: One of the paramount benefits of structural testing is its ability to achieve exhaustive code coverage. It meticulously examines branches, loops, and individual statements within the code, ensuring that no part is left untested. This level of scrutiny is vital for uncovering errors that might elude functional testing, thereby bolstering the software’s reliability and performance.\nDetection of Concealed Bugs: Structural testing shines in its ability to unearth bugs that lurk beneath the surface, invisible to more superficial testing methodologies. It probes into the software’s inner mechanisms, identifying edge cases and unique conditions that might otherwise remain undiscovered until after deployment.\nStreamlined Debugging Process: The intimate association between structural testing and the application’s codebase significantly eases the debugging process. When a test fails, developers can quickly pinpoint the exact location of the fault within the code, facilitating a more efficient and targeted debugging effort.\nElevated Software Quality: By verifying that the code behaves as intended across a wide array of scenarios and inputs, structural testing contributes significantly to enhancing the software’s overall quality. This comprehensive examination helps ensure a superior user experience and can substantially reduce the need for future maintenance and bug fixes.\nSupport for Refactoring and Integration: Structural testing is invaluable during code refactoring and the integration of new features. It provides a safety net that ensures modifications do not introduce new errors, allowing the software to evolve while maintaining its integrity and functionality.\nBolstering Security: Given its thorough exploration of code pathways, structural testing plays a key role in identifying potential security vulnerabilities. This is crucial for applications dealing with sensitive information or those that are integral to business operations, as it helps prevent exploitations that could lead to data breaches or other security incidents.\nCompliance with Regulatory Standards: In certain industries, achieving comprehensive code coverage through structural testing is not just beneficial but mandated. This ensures that software adheres to rigorous quality and safety standards, an essential requirement in sectors where software reliability is paramount.\nTo sum up, structural testing is indispensable for ensuring that software is not only functional but also robust, secure, and of high quality. It complements functional testing by offering a deep dive into the software’s internal mechanics, thereby playing a critical role in the development of reliable, efficient, and secure applications.\nImplementation Our test case mainly focuses on method coverage,but also improves some line coverage and branch coverage rate.\nWith the help of IDEA coverage tool, we quickly found some targets. They are:\nBoth method are relatively simple, the first one handles HTTP POST requests to the root URL (\"/\") and return some kinds of map info such as current date etc., and the second one is mapping a KV pair into the end of actuator info.\nChallenges Encountered Our initial attempts to cover the first target with test cases resulted in multiple failures. Specifically, we encountered a 401 Unauthorized status instead of the expected 200 OK. Upon reviewing the debug logs, we discovered that Spring Security’s CSRF (Cross-site request forgery) protection was blocking the POST requests.\nDespite disabling CSRF protection, our tests still returned a 404 status, indicating further complications possibly related to requiring a valid token or additional configuration adjustments.\nGiven the complexity of Spring Security and our limited experience with it, we decided to redirect our efforts towards other methods for coverage improvement. Spring Security’s comprehensive nature suggested that a deeper dive into its configuration and security mechanisms would be necessary for successful method coverage in areas protected by security policies.\nWe turn our attention to the second method. It seems like this code is brief, but in fact it does a lot of things under the hood. You may notice that the method itself introduce a new Builder class. See the below picture to take a look at this class itself.\nLet’s analyze what this code does specifically from the source code perspective.\nInterface Implementation: It overrides the InfoContributor interface’s contribute method. Implementing this interface enables the addition of custom information to the Actuator’s /info endpoint through the introduction of a Builder class.\nDetail Addition: Utilizes the Builder class’s withDetail method to add a key-value pair (example key with a map object {someKey, someValue}) as custom information.\nHashMap Initialization and Construction: The Builder initializes and constructs a new HashMap, incorporating existing info content. This step ensures that any previously available information is retained and integrated with the new details.\nInfo Map Construction: It calls the withDetail method again to incorporate the custom information into the new HashMap, effectively building the enriched info map.\nInfo Map Retrieval: Upon request to the /info endpoint, the method returns the newly constructed info map, now containing both existing and newly added details.\nTest case The test case aims to verify the functionality of the override contribute method within the Spring Boot Actuator’s info endpoint. It focuses on ensuring that:\nThe HTTP connection is successfully established. The info endpoint is correctly configured and returns the expected build key. The contribute method functions as intended, allowing for custom information to be added to the endpoint. @Test @SuppressWarnings(\"unchecked\") void testInfo() { ResponseEntity\u003cMap\u003cString, Object\u003e\u003e entity = asMapEntity( this.restTemplate.withBasicAuth(\"user\", \"password\").getForEntity(\"/actuator/info\", Map.class)); assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(entity.getBody()).containsKey(\"build\"); Map\u003cString, Object\u003e body = entity.getBody(); Map\u003cString, Object\u003e example = (Map\u003cString, Object\u003e) body.get(\"example\"); assertThat(example).containsEntry(\"someKey\", \"someValue\"); } Assertions HTTP Status Check: Validates that the HTTP connection to the info endpoint is established, indicated by an HttpStatus.OK response. build Key Existence: Confirms that the info endpoint is functioning correctly by checking for the presence of the build key, a critical component of the endpoint’s response. contribute Method Functionality: Verifies that the contribute method properly adds custom information (“someKey”: “someValue”) to the endpoint’s response. These are the coverage output after this tested case added. You can clearly see the changes in coverage methods, lines and branches. After incorporating this test case, the coverage metrics showed significant improvements in methods, lines, and branches within the tested class. However, to further enhance coverage, especially for untested branches and methods in the info class, additional tests could be considered. These might include:\nTesting the equal method with various expected outcomes. Calling the get method with both valid and invalid types. Such tests would delve deeper into the framework’s internal functionality rather than focusing solely on the actuator smoke test system.\nConclusion This test case effectively enhances the test coverage of the Spring Boot Actuator’s info endpoint, particularly focusing on the contribute method’s functionality. For comprehensive coverage, further tests exploring additional branches and methods within the info class are recommended.\n","wordCount":"1174","inLanguage":"en","image":"https://www.mrwblog.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-04-01T00:00:00Z","dateModified":"2024-04-01T00:00:00Z","author":{"@type":"Person","name":"Mr.W"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.mrwblog.com/posts/springboottest3/"},"publisher":{"@type":"Organization","name":"Mr.W's Blog","logo":{"@type":"ImageObject","url":"https://www.mrwblog.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.mrwblog.com/ accesskey=h title="Home (Alt + H)"><img src=https://www.mrwblog.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.mrwblog.com/archives/ title=Archieves><span>Archieves</span></a></li><li><a href=https://www.mrwblog.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.mrwblog.com/archive/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.mrwblog.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.mrwblog.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Spring Boot Software Testing 3 - White Box Testing and Coverage</h1><div class=post-meta><span title='2024-04-01 00:00:00 +0000 UTC'>April 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1174 words&nbsp;·&nbsp;Mr.W</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#white-box-testing-and-coverage aria-label="White Box Testing and Coverage">White Box Testing and Coverage</a><ul><li><a href=#the-crucial-role-of-structural-testing aria-label="The Crucial Role of Structural Testing">The Crucial Role of Structural Testing</a></li><li><a href=#implementation aria-label=Implementation>Implementation</a><ul><li><a href=#challenges-encountered aria-label="Challenges Encountered">Challenges Encountered</a></li></ul></li><li><a href=#test-case aria-label="Test case">Test case</a><ul><li><a href=#assertions aria-label=Assertions>Assertions</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=white-box-testing-and-coverage>White Box Testing and Coverage<a hidden class=anchor aria-hidden=true href=#white-box-testing-and-coverage>#</a></h1><p>Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application&rsquo;s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software&rsquo;s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments.</p><h2 id=the-crucial-role-of-structural-testing>The Crucial Role of Structural Testing<a hidden class=anchor aria-hidden=true href=#the-crucial-role-of-structural-testing>#</a></h2><ol><li><p><strong>Enhanced Code Coverage</strong>: One of the paramount benefits of structural testing is its ability to achieve exhaustive code coverage. It meticulously examines branches, loops, and individual statements within the code, ensuring that no part is left untested. This level of scrutiny is vital for uncovering errors that might elude functional testing, thereby bolstering the software&rsquo;s reliability and performance.</p></li><li><p><strong>Detection of Concealed Bugs</strong>: Structural testing shines in its ability to unearth bugs that lurk beneath the surface, invisible to more superficial testing methodologies. It probes into the software&rsquo;s inner mechanisms, identifying edge cases and unique conditions that might otherwise remain undiscovered until after deployment.</p></li><li><p><strong>Streamlined Debugging Process</strong>: The intimate association between structural testing and the application&rsquo;s codebase significantly eases the debugging process. When a test fails, developers can quickly pinpoint the exact location of the fault within the code, facilitating a more efficient and targeted debugging effort.</p></li><li><p><strong>Elevated Software Quality</strong>: By verifying that the code behaves as intended across a wide array of scenarios and inputs, structural testing contributes significantly to enhancing the software&rsquo;s overall quality. This comprehensive examination helps ensure a superior user experience and can substantially reduce the need for future maintenance and bug fixes.</p></li><li><p><strong>Support for Refactoring and Integration</strong>: Structural testing is invaluable during code refactoring and the integration of new features. It provides a safety net that ensures modifications do not introduce new errors, allowing the software to evolve while maintaining its integrity and functionality.</p></li><li><p><strong>Bolstering Security</strong>: Given its thorough exploration of code pathways, structural testing plays a key role in identifying potential security vulnerabilities. This is crucial for applications dealing with sensitive information or those that are integral to business operations, as it helps prevent exploitations that could lead to data breaches or other security incidents.</p></li><li><p><strong>Compliance with Regulatory Standards</strong>: In certain industries, achieving comprehensive code coverage through structural testing is not just beneficial but mandated. This ensures that software adheres to rigorous quality and safety standards, an essential requirement in sectors where software reliability is paramount.</p></li></ol><blockquote><p>To sum up, structural testing is indispensable for ensuring that software is not only functional but also robust, secure, and of high quality. It complements functional testing by offering a deep dive into the software&rsquo;s internal mechanics, thereby playing a critical role in the development of reliable, efficient, and secure applications.</p></blockquote><hr><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Our test case mainly focuses on method coverage,but also improves some line coverage and branch coverage rate.</p><p>With the help of <code>IDEA</code> coverage tool, we quickly found some targets. They are:</p><p><img loading=lazy src=fail_test_target.png alt></p><hr><p><img loading=lazy src=test_target2.png alt></p><p>Both method are relatively simple, the first one handles HTTP POST requests to the root URL ("/") and return some kinds of map info such as current date etc., and the second one is mapping a KV pair into the end of actuator <code>info</code>.</p><h3 id=challenges-encountered>Challenges Encountered<a hidden class=anchor aria-hidden=true href=#challenges-encountered>#</a></h3><p>Our initial attempts to cover the first target with test cases resulted in multiple failures. Specifically, we encountered a <code>401 Unauthorized</code> status instead of the expected <code>200 OK</code>. Upon reviewing the debug logs, we discovered that Spring Security&rsquo;s CSRF (Cross-site request forgery) protection was blocking the POST requests.</p><p><img loading=lazy src=csrf_disable.png alt></p><p>Despite disabling CSRF protection, our tests still returned a <code>404</code> status, indicating further complications possibly related to requiring a valid token or additional configuration adjustments.</p><p>Given the complexity of Spring Security and our limited experience with it, we decided to redirect our efforts towards other methods for coverage improvement. Spring Security&rsquo;s comprehensive nature suggested that a deeper dive into its configuration and security mechanisms would be necessary for successful method coverage in areas protected by security policies.</p><hr><p>We turn our attention to the second method. It seems like this code is brief, but in fact it does a lot of things under the hood. You may notice that the method itself introduce a new <code>Builder</code> class. See the below picture to take a look at this class itself.</p><p><img loading=lazy src=infoClasssBefore.png alt></p><p>Let&rsquo;s analyze what this code does specifically from the source code perspective.</p><ol><li><p><strong>Interface Implementation</strong>: It overrides the <code>InfoContributor</code> interface&rsquo;s <code>contribute</code> method. Implementing this interface enables the addition of custom information to the Actuator&rsquo;s /info endpoint through the introduction of a <code>Builder</code> class.</p></li><li><p><strong>Detail Addition</strong>: Utilizes the <code>Builder</code> class&rsquo;s withDetail method to add a key-value pair (example key with a map object {<code>someKey, someValue</code>}) as custom information.</p></li><li><p><strong>HashMap Initialization and Construction</strong>: The Builder initializes and constructs a new HashMap, incorporating existing info content. This step ensures that any previously available information is retained and integrated with the new details.</p></li><li><p><strong>Info Map Construction</strong>: It calls the withDetail method again to incorporate the custom information into the new HashMap, effectively building the enriched info map.</p></li><li><p><strong>Info Map Retrieval</strong>: Upon request to the /info endpoint, the method returns the newly constructed info map, now containing both existing and newly added details.</p></li></ol><hr><h2 id=test-case>Test case<a hidden class=anchor aria-hidden=true href=#test-case>#</a></h2><p>The test case aims to verify the functionality of the override <code>contribute</code> method within the Spring Boot Actuator&rsquo;s <code>info</code> endpoint. It focuses on ensuring that:</p><ul><li>The HTTP connection is successfully established.</li><li>The info endpoint is correctly configured and returns the expected build key.</li><li>The contribute method functions as intended, allowing for custom information to be added to the endpoint.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@SuppressWarnings</span><span class=p>(</span><span class=s>&#34;unchecked&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kt>void</span><span class=w> </span><span class=nf>testInfo</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>ResponseEntity</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>entity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>asMapEntity</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>this</span><span class=p>.</span><span class=na>restTemplate</span><span class=p>.</span><span class=na>withBasicAuth</span><span class=p>(</span><span class=s>&#34;user&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;password&#34;</span><span class=p>).</span><span class=na>getForEntity</span><span class=p>(</span><span class=s>&#34;/actuator/info&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Map</span><span class=p>.</span><span class=na>class</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>assertThat</span><span class=p>(</span><span class=n>entity</span><span class=p>.</span><span class=na>getStatusCode</span><span class=p>()).</span><span class=na>isEqualTo</span><span class=p>(</span><span class=n>HttpStatus</span><span class=p>.</span><span class=na>OK</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>assertThat</span><span class=p>(</span><span class=n>entity</span><span class=p>.</span><span class=na>getBody</span><span class=p>()).</span><span class=na>containsKey</span><span class=p>(</span><span class=s>&#34;build&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>entity</span><span class=p>.</span><span class=na>getBody</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>example</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=n>body</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=s>&#34;example&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>assertThat</span><span class=p>(</span><span class=n>example</span><span class=p>).</span><span class=na>containsEntry</span><span class=p>(</span><span class=s>&#34;someKey&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;someValue&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=assertions>Assertions<a hidden class=anchor aria-hidden=true href=#assertions>#</a></h3><ol><li><strong>HTTP Status Check</strong>: Validates that the HTTP connection to the <code>info</code> endpoint is established, indicated by an <code>HttpStatus.OK</code> response.</li><li><strong><code>build</code> Key Existence</strong>: Confirms that the info endpoint is functioning correctly by checking for the presence of the <code>build</code> key, a critical component of the endpoint&rsquo;s response.</li><li><strong><code>contribute</code> Method Functionality</strong>: Verifies that the <code>contribute</code> method properly adds custom information (<strong>&ldquo;someKey&rdquo;: &ldquo;someValue&rdquo;</strong>) to the endpoint&rsquo;s response.</li></ol><p>These are the coverage output after this tested case added. You can clearly see the changes in coverage methods, lines and branches.
<img loading=lazy src=test_target_after.png alt></p><p><img loading=lazy src=infoClassAfter.png alt></p><p>After incorporating this test case, the coverage metrics showed significant improvements in methods, lines, and branches within the tested class. However, to further enhance coverage, especially for untested branches and methods in the info class, additional tests could be considered. These might include:</p><ul><li>Testing the equal method with various expected outcomes.</li><li>Calling the get method with both valid and invalid types.</li></ul><p>Such tests would delve deeper into the framework&rsquo;s internal functionality rather than focusing solely on the actuator smoke test system.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>This test case effectively enhances the test coverage of the Spring Boot Actuator&rsquo;s info endpoint, particularly focusing on the contribute method&rsquo;s functionality. For comprehensive coverage, further tests exploring additional branches and methods within the info class are recommended.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.mrwblog.com/tags/spring-boot/>Spring Boot</a></li><li><a href=https://www.mrwblog.com/tags/java/>Java</a></li><li><a href=https://www.mrwblog.com/tags/actuator/>Actuator</a></li></ul><nav class=paginav><a class=prev href=https://www.mrwblog.com/posts/springboottest4/><span class=title>« Prev</span><br><span>Spring Boot Software Testing 4 - Continuous Integration</span>
</a><a class=next href=https://www.mrwblog.com/posts/springboottest2/><span class=title>Next »</span><br><span>Spring Boot Software Testing 2 - Actuator - Finite State Machine</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.mrwblog.com/>Mr.W's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>