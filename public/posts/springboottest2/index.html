<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring Boot Software Testing 2 - Actuator - Finite State Machine | Mr.W's Blog</title>
<meta name=keywords content="Spring Boot,Java,Actuator"><meta name=description content="Finite State machine
Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.
Key benefits include:

Simplification: Reducing complex systems to manageable models.
Exhaustive Testing: Enabling complete coverage of all possible states and transitions.
Automated Testing: Supporting the generation of test cases and regression testing.
Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods.

Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes."><meta name=author content="Mr.W"><link rel=canonical href=http://localhost:1313/posts/springboottest2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.c37eecdda64ea639c287617a9bf0cc1589bbc6eb564291c959b6ed3722751621.css integrity="sha256-w37s3aZOpjnCh2F6m/DMFYm7xutWQpHJWbbtNyJ1FiE=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/springboottest2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=disabled"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","disabled")}</script><meta property="og:url" content="http://localhost:1313/posts/springboottest2/"><meta property="og:site_name" content="Mr.W's Blog"><meta property="og:title" content="Spring Boot Software Testing 2 - Actuator - Finite State Machine"><meta property="og:description" content="Finite State machine Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.
Key benefits include:
Simplification: Reducing complex systems to manageable models. Exhaustive Testing: Enabling complete coverage of all possible states and transitions. Automated Testing: Supporting the generation of test cases and regression testing. Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods. Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-31T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-31T00:00:00+00:00"><meta property="article:tag" content="Spring Boot"><meta property="article:tag" content="Java"><meta property="article:tag" content="Actuator"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Spring Boot Software Testing 2 - Actuator - Finite State Machine"><meta name=twitter:description content="Finite State machine
Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.
Key benefits include:

Simplification: Reducing complex systems to manageable models.
Exhaustive Testing: Enabling complete coverage of all possible states and transitions.
Automated Testing: Supporting the generation of test cases and regression testing.
Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods.

Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Spring Boot Software Testing 2 - Actuator - Finite State Machine","item":"http://localhost:1313/posts/springboottest2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring Boot Software Testing 2 - Actuator - Finite State Machine","name":"Spring Boot Software Testing 2 - Actuator - Finite State Machine","description":"Finite State machine Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.\nKey benefits include:\nSimplification: Reducing complex systems to manageable models. Exhaustive Testing: Enabling complete coverage of all possible states and transitions. Automated Testing: Supporting the generation of test cases and regression testing. Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods. Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes.\n","keywords":["Spring Boot","Java","Actuator"],"articleBody":"Finite State machine Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.\nKey benefits include:\nSimplification: Reducing complex systems to manageable models. Exhaustive Testing: Enabling complete coverage of all possible states and transitions. Automated Testing: Supporting the generation of test cases and regression testing. Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods. Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes.\nSrping boot actuator Spring boot actuator is one of the most important component from spring boot.provides a set of ready-to-use features to help you monitor and manage your application. These features allow you to inspect the internal state of your application, such as health status, metrics, environment information, and more. This is especially useful for microservices architectures in production environments.\nThere are some endpoints from actuator:\n/actuator: The root endpoint that lists all available actuator endpoints. /health: Summarizes the health status of your application. /heapdump: Triggers a dump of the Java heap. /httptrace: Shows HTTP trace information (by default, the last 100 HTTP request-response exchanges). /info: Displays arbitrary application info. /loggers: Enables viewing and modifying the logging level of application loggers. /metrics: Shows ‘metrics’ information for the current application. /shutdown: Lets you gracefully shut down the application (disabled by default). /env: Exposes properties from Spring’s ConfigurableEnvironment. This is the function what actuator offers; I won’t explain the detailed functions here. The spring boot basic policy is: All the function except /health will be treated as sensitive data which will not open to the public until the auth passed.\nThe finite state machine without verification will be look like this:\nAll the actuator function except health will be received a http 302 redirect response. The health will be received http ok and show the data query.\nLet’s see how the finite state machine change when verification completed.\nNow, the server will make more response, not just including all the actuator services, but also the exception handling. like /foo will response http500. http 403 will pop up when make a GET request in prohibited port when CORS enable.\nBelow shows a bunch of screenshots about how it actually reacts:\nfirst the login page try to enter actuator/env and excute, page automatically fall back to login page try use actuator/health get the new return /actuator/env now functional after entering correct username and password try exception page, get http 500 try to get some page not existed, get http 404 login fail can also be a simple state machine, but it’s code implementation based on spring security, hence not within the scope of this discussion ","wordCount":"513","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-03-31T00:00:00Z","dateModified":"2024-03-31T00:00:00Z","author":{"@type":"Person","name":"Mr.W"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/springboottest2/"},"publisher":{"@type":"Organization","name":"Mr.W's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archieves><span>Archieves</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/archive/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Spring Boot Software Testing 2 - Actuator - Finite State Machine</h1><div class=post-meta><span title='2024-03-31 00:00:00 +0000 UTC'>March 31, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;513 words&nbsp;·&nbsp;Mr.W</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#finite-state-machine aria-label="Finite State machine">Finite State machine</a><ul><li><a href=#srping-boot-actuator aria-label="Srping boot actuator">Srping boot actuator</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=finite-state-machine>Finite State machine<a hidden class=anchor aria-hidden=true href=#finite-state-machine>#</a></h1><p>Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.</p><p>Key benefits include:</p><ul><li>Simplification: Reducing complex systems to manageable models.</li><li>Exhaustive Testing: Enabling complete coverage of all possible states and transitions.</li><li>Automated Testing: Supporting the generation of test cases and regression testing.</li><li>Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods.</li></ul><p>Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes.</p><h2 id=srping-boot-actuator>Srping boot actuator<a hidden class=anchor aria-hidden=true href=#srping-boot-actuator>#</a></h2><p>Spring boot actuator is one of the most important component from spring boot.provides a set of ready-to-use features to help you monitor and manage your application. These features allow you to inspect the internal state of your application, such as health status, metrics, environment information, and more. This is especially useful for microservices architectures in production environments.</p><p>There are some endpoints from actuator:</p><ul><li><code>/actuator</code>: The root endpoint that lists all available actuator endpoints.</li><li><code>/health</code>: Summarizes the health status of your application.</li><li><code>/heapdump</code>: Triggers a dump of the Java heap.</li><li><code>/httptrace</code>: Shows HTTP trace information (by default, the last 100 HTTP request-response exchanges).</li><li><code>/info</code>: Displays arbitrary application info.</li><li><code>/loggers</code>: Enables viewing and modifying the logging level of application loggers.</li><li><code>/metrics</code>: Shows ‘metrics’ information for the current application.</li><li><code>/shutdown</code>: Lets you gracefully shut down the application (disabled by default).</li><li><code>/env</code>: Exposes properties from Spring’s ConfigurableEnvironment.</li></ul><p>This is the function what actuator offers; I won’t explain the detailed functions here. The spring boot basic policy is: <strong>All the function except /health will be treated as sensitive data which will not open to the public until the auth passed.</strong></p><hr><p>The finite state machine without verification will be look like this:</p><p><img loading=lazy src=/posts/springboottest2/diagram1.svg></p><p>All the actuator function except health will be received a http 302 redirect response. The health will be received http ok and show the data query.</p><p>Let&rsquo;s see how the finite state machine change when verification completed.</p><p><img loading=lazy src=/posts/springboottest2/diagram2.svg></p><p>Now, the server will make more response, not just including all the actuator services, but also the exception handling. like <code>/foo</code> will response http500. http 403 will pop up when make a GET request in prohibited port when CORS enable.</p><p>Below shows a bunch of screenshots about how it actually reacts:</p><blockquote><p>first the login page
<img loading=lazy src=/posts/springboottest2/1.png></p></blockquote><blockquote><p>try to enter actuator/env and excute, page automatically fall back to login page
<img loading=lazy src=/posts/springboottest2/2.png></p></blockquote><blockquote><p>try use <code>actuator/health</code> get the new return
<img loading=lazy src=/posts/springboottest2/3.png></p></blockquote><blockquote><p><code>/actuator/env</code> now functional after entering correct username and password
<img loading=lazy src=/posts/springboottest2/4.png></p></blockquote><blockquote><p>try exception page, get http 500
<img loading=lazy src=/posts/springboottest2/5.png></p></blockquote><blockquote><p>try to get some page not existed, get http 404
<img loading=lazy src=/posts/springboottest2/6.png></p></blockquote><blockquote><p>login fail can also be a simple state machine, but it&rsquo;s code implementation based on spring security, hence not within the scope of this discussion
<img loading=lazy src=/posts/springboottest2/7.png></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/spring-boot/>Spring Boot</a></li><li><a href=http://localhost:1313/tags/java/>Java</a></li><li><a href=http://localhost:1313/tags/actuator/>Actuator</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/springboottest3/><span class=title>« Prev</span><br><span>Spring Boot Software Testing 3 - White Box Testing and Coverage</span>
</a><a class=next href=http://localhost:1313/posts/springboottest1/><span class=title>Next »</span><br><span>Spring Boot Software Testing 1, Partitioning and Functioning testing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Mr.W's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>