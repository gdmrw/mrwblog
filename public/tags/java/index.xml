<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on Mr.W&#39;s Blog</title>
    <link>http://localhost:1313/tags/java/</link>
    <description>Recent content in Java on Mr.W&#39;s Blog</description>
    <image>
      <title>Mr.W&#39;s Blog</title>
      <url>http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.140.2</generator>
    <language>en</language>
    <lastBuildDate>Sat, 13 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SpringBoot JDBC Reverse Analysis</title>
      <link>http://localhost:1313/posts/springbootjdbc/</link>
      <pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springbootjdbc/</guid>
      <description>&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;This is some of my thinking about the Spring framework&amp;rsquo;s JDBC from my reverse engineering course. The &lt;code&gt;location model&lt;/code&gt; image shows the abstract classes, implementation classes, interfaces, and methods that are directly or indirectly involved when executing the query method. The &lt;code&gt;workflow&lt;/code&gt; image depicts the detailed function call process after initiating the JDBC query method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Due to space and time limitations, other branches resulting from polymorphism are not shown; only the chain produced by importing SQL of string type is displayed here.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot Software Testing 6 - Static Analyzers</title>
      <link>http://localhost:1313/posts/springboottest6/</link>
      <pubDate>Thu, 04 Apr 2024 13:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottest6/</guid>
      <description>&lt;h1 id=&#34;static-analyzers&#34;&gt;Static Analyzers&lt;/h1&gt;
&lt;p&gt;Static analysis tools are essential in software development, focusing on improving code quality, identifying bugs, and ensuring adherence to coding standards without executing the code. They serve multiple purposes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Code Quality: Enhance code readability, maintainability, and efficiency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bug Detection: Identify and fix errors early in the development process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Security: Detect potential security vulnerabilities.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Performance: Highlight inefficient code patterns for optimization.
These tools are used throughout the development lifecycle, particularly in:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot Software Testing 5 - Testable Design and Mocking</title>
      <link>http://localhost:1313/posts/springboottest5/</link>
      <pubDate>Thu, 04 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottest5/</guid>
      <description>&lt;h1 id=&#34;testable-design-and-mocking&#34;&gt;Testable Design and Mocking&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;What is testable design, and what kinds of design in java are testable?&lt;/p&gt;
&lt;p&gt;In Java, achieving a testable design is about adhering to principles and practices that minimize coupling, maximize cohesion, and facilitate isolation of components for testing. It involves strategic use of design patterns, architectural decisions that favor testability, and leveraging tools and frameworks that support automated testing. This approach not only makes your code more testable but also improves its overall design and maintainability.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot Software Testing 4 - Continuous Integration</title>
      <link>http://localhost:1313/posts/springboottest4/</link>
      <pubDate>Mon, 01 Apr 2024 13:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottest4/</guid>
      <description>&lt;h1 id=&#34;continuous-integration&#34;&gt;Continuous Integration&lt;/h1&gt;
&lt;p&gt;Continuous Integration (CI) is a software development practice where developers frequently merge their code changes into a central repository, preferably multiple times a day. Each merge triggers an automated build and testing process, which helps in identifying and addressing integration errors as quickly as possible. The primary purpose of CI is to improve software quality and accelerate the development process.&lt;/p&gt;
&lt;p&gt;Key aspects of Continuous Integration include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Automated Building and Testing&lt;/strong&gt;: Automated tools are used to compile the code and run tests every time changes are integrated. This ensures that the software is always in a state where it can be deployed.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot Software Testing 3 - White Box Testing and Coverage</title>
      <link>http://localhost:1313/posts/springboottest3/</link>
      <pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottest3/</guid>
      <description>&lt;h1 id=&#34;white-box-testing-and-coverage&#34;&gt;White Box Testing and Coverage&lt;/h1&gt;
&lt;p&gt;Structural testing, often referred to as white-box testing, is a rigorous methodology for evaluating the internal workings of a software application. This technique delves into the application&amp;rsquo;s source code, architecture, and design, offering a detailed view of its internal pathways. Unlike black-box testing, which assesses the software&amp;rsquo;s external functionality without regard to its internal mechanisms, structural testing demands an intimate understanding of the codebase. This approach allows testers to meticulously examine execution paths, logic flows, and the outcomes of various code segments.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot Software Testing 2 - Actuator - Finite State Machine</title>
      <link>http://localhost:1313/posts/springboottest2/</link>
      <pubDate>Sun, 31 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottest2/</guid>
      <description>&lt;h1 id=&#34;finite-state-machine&#34;&gt;Finite State machine&lt;/h1&gt;
&lt;p&gt;Finite models are essential in testing for simplifying complex systems, allowing exhaustive testing, and facilitating automated test case generation. They offer a clear way to represent systems as finite state machines, making it possible to explore all possible states and transitions. This approach is critical for ensuring systems behave as expected under every scenario, especially in critical applications where failure is unacceptable.&lt;/p&gt;
&lt;p&gt;Key benefits include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simplification: Reducing complex systems to manageable models.&lt;/li&gt;
&lt;li&gt;Exhaustive Testing: Enabling complete coverage of all possible states and transitions.&lt;/li&gt;
&lt;li&gt;Automated Testing: Supporting the generation of test cases and regression testing.&lt;/li&gt;
&lt;li&gt;Formal Verification: Allowing mathematical proofs of system correctness through model checking and other formal methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finite models are widely used in software and hardware testing to improve test coverage, find potential issues, and ensure system reliability. However, challenges such as scalability and the accuracy of the models must be managed to ensure effective testing outcomes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot Software Testing 1, Partitioning and Functioning testing</title>
      <link>http://localhost:1313/posts/springboottest1/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/springboottest1/</guid>
      <description>&lt;p&gt;Spring Boot is a project under the Spring Framework that simplifies developing, configuring, and deploying Spring-based applications. It promotes convention over configuration by offering pre-configured setups and auto-configuration based on project dependencies, eliminating much of the manual setup and configuration work. Spring Boot applications are stand-alone, containing an embedded web server for easy deployment as a single executable JAR. It offers opinionated defaults to reduce development effort, while still allowing for customization. Features like Actuator provide built-in endpoints for application monitoring and management. Primarily written in Java, Spring Boot supports other JVM languages like Kotlin and Groovy, making it versatile for various enterprise applications. Its goal is to enable quick application startup with less code and configuration hassle.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
